import json
import os
from pathlib import Path

import pytest
import testing_tools as tt


# Cmdline options
def pytest_addoption(parser):
    parser.addoption(
        "--test-traces",
        action="store_true",
        help="Print to console and HTML report only traces generated by test code",
    )
    parser.addoption(
        "--build-scenarios",
        action="store_true",
        help="Execute cargo build for test scenarios binary",
    )


# Hooks
@pytest.hookimpl(tryfirst=True)
def pytest_sessionstart(session):
    # Check if the --function argument was passed
    if session.config.getoption("--build-scenarios"):
        print("Building test scenarios binary...")
        build_scenarios()


def build_scenarios(**kwargs):
    """
    Build test scenarios binary using cargo
    """
    try:
        binary = tt.build_rust_scenarios(
            Path(__file__).parents[2] / "rust_test_scenarios"
        )
    except Exception as e:
        pytest.exit(
            f"Failed to build rust test scenarios: {e}",
            returncode=1,
        )
    # Set the environment variable for the test binary
    os.environ[tt.TEST_BIN_ENV_VAR] = str(binary)


# Fixtures
@pytest.fixture(scope="class")
def execute_rust(test_config, test_case_name):
    """
    Returns list of raw json messages from the test binary execution.
    """
    return tt.execute_and_parse(test_config, test_case_name, expect_hang=False)


@pytest.fixture(scope="class")
def execute_rust_expect_hang(test_config, test_case_name):
    """
    Returns list of raw json messages from the test binary execution and expects the binary to hang.
    """
    return tt.execute_and_parse(test_config, test_case_name, expect_hang=True)


@pytest.fixture(scope="class")
def unfiltered_test_results(execute_rust):
    """
    Returns LogContainer with all messages from the test binary execution.
    """
    messages = execute_rust
    logs = [tt.ResultEntry(msg) for msg in messages]
    return tt.LogContainer.from_entries(logs)


@pytest.fixture(scope="class")
def targeted_test_results(unfiltered_test_results):
    """
    Returns LogContainer messages that are generated strictly by the tested code.
    """
    [*results] = unfiltered_test_results.get_logs_by_field(
        field="target", pattern="rust_test_scenarios.*"
    )
    return tt.LogContainer.from_entries(results)


@pytest.fixture(scope="class")
def test_results(targeted_test_results):
    """
    Returns LogContainer messages with just INFO level.
    """
    [*results] = targeted_test_results.get_logs_by_field(field="level", pattern="INFO")
    return tt.LogContainer.from_entries(results)


# Console log and HTML report
@pytest.fixture(scope="function", autouse=True)
def print_to_report(execute_rust, targeted_test_results, request):
    if request.config.getoption("--test-traces"):
        traces = targeted_test_results
    else:
        traces = execute_rust

    for trace in traces:
        # Convert timestamp to string for better readability in the report
        trace["timestamp"] = str(trace["timestamp"])
        print(str(trace))


def pytest_html_report_title(report):
    # Change report title
    # report.title = "Report1"
    ...


def pytest_html_results_table_header(cells):
    # Create additional table headers
    cells.insert(3, "<th>Test Case Name</th>")
    cells.insert(2, "<th>Description</th>")
    cells.insert(1, "<th>Test Input</th>")


def pytest_html_results_table_row(report, cells):
    # Create additional table columns with TC __doc__ and execution date
    cells.insert(3, f"<td><pre>{report.tc}</pre></td>")
    cells.insert(2, f"<td><pre>{report.description}</pre></td>")
    cells.insert(
        1,
        f'<td><pre style="white-space:pre-wrap;word-wrap:break-word">{json.dumps(report.input)}</pre></td>',
    )


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    # Extract TC's data
    outcome = yield
    report = outcome.get_result()
    report.description = str(item.function.__doc__)
    report.tc = item.funcargs.get("test_case_name", "")
    report.input = item.funcargs.get("test_config", "")
